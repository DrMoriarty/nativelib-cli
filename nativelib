#!/usr/bin/env python

import sys, os, getopt, json, shutil, traceback, tarfile, time, uuid
import urllib.request
import pprint
import pathlib

VERSION = "0.1.0"
API = "https://api.bintray.com"
SUBJECT = "mobilap"
REPO = "nativelib"
FORCE = False
OVERWRITE = False
CLEANUP = True
PROJECT_META = None
STORAGE = {}
PLATFORMS = []

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_error(e):
    print('{0}{2}{1}'.format(bcolors.FAIL, bcolors.ENDC, e))

def print_warning(w):
    print('{0}{2}{1}'.format(bcolors.WARNING, bcolors.ENDC, w))

def print_bold(s):
    print('{0}{2}{1}'.format(bcolors.BOLD, bcolors.ENDC, s))

def get_packages():
    try:
        contents = urllib.request.urlopen("{0}/repos/{1}/{2}/packages".format(API, SUBJECT, REPO)).read()
        return json.loads(contents)
    except urllib.error.HTTPError as e:
        print_error(e)
        return None

def get_package_info(package_name):
    contents = urllib.request.urlopen("{0}/packages/{1}/{2}/{3}".format(API, SUBJECT, REPO, package_name)).read()
    return json.loads(contents)

def search_packages(name):
    contents = urllib.request.urlopen("{0}/search/packages?name={3}&subject={1}&repo={2}".format(API, SUBJECT, REPO, name)).read()
    return json.loads(contents)

def package_version_info(package_name, version = None):
    if version == None or version == '':
        version = '_latest'
    try:
        contents = urllib.request.urlopen("{0}/packages/{1}/{2}/{3}/versions/{4}".format(API, SUBJECT, REPO, package_name, version)).read()
        return json.loads(contents)
    except urllib.error.HTTPError as e:
        print_error(e)
        return None

def package_files(package_name, version = None):
    try:
        url = ''
        if version is None:
            url = "{0}/packages/{1}/{2}/{3}/files".format(API, SUBJECT, REPO, package_name)
        else:
            url = "{0}/packages/{1}/{2}/{3}/versions/{4}/files".format(API, SUBJECT, REPO, package_name, version)
        contents = urllib.request.urlopen(url).read()
        return json.loads(contents)
    except urllib.error.HTTPError as e:
        print_error(e)
        return None
    
def show_package_info(info):
    pprint.pprint(info)

def package_home(package_name, version, create=False):
    home = str(pathlib.Path.home())
    path = os.path.join(home, ".nativelib", "packages", package_name, version)
    if create:
        try:
            os.makedirs(path)
        except FileExistsError:
            pass
    return path

def journal_home():
    if PROJECT_META is None:
        return None
    home = str(pathlib.Path.home())
    path = os.path.join(home, '.nativelib', 'projects', PROJECT_META['id'])
    if not os.path.exists(path):
        os.makedirs(path)
    return path

def download(url, filename, path):
    def _progress(count, block_size, total_size):
        done = int(100*(count*block_size)/total_size)
        if done > 100:
            done = 100
        d = int(done/10)
        sys.stdout.write('\r{}\t[{}{}] {}%'.format(filename, 'â–ˆ' * d, '.' * (10-d), done))
        #sys.stdout.write('\r{}\t{}%'.format(filename, done))
        sys.stdout.flush()
    (filepath, headers) = urllib.request.urlretrieve(url, os.path.join(path, filename), reporthook=_progress)
    sys.stdout.write('\n')
    return filepath

def split_package_name(package_name):
    p = package_name
    v = None
    if '@' in p:
        pk = p.split('@')
        p = pk[0]
        v = pk[1]
    return p, v

def load_project_meta():
    global PROJECT_META
    global PLATFORMS
    try:
        meta_str = pathlib.Path('.nativelib').read_text()
        meta = json.loads(meta_str)
        PROJECT_META = meta
    except FileNotFoundError as e:
        PROJECT_META = {
            'id': str(uuid.uuid4()),
            'platforms': ['all'],
            'packages': {}
        }
        save_project_meta()
    PLATFORMS = PROJECT_META['platforms']

def save_project_meta():
    with open('.nativelib', 'w') as f:
        json.dump(PROJECT_META, f, indent = 4)

def is_package_installed(package_name, version):
    if package_name in PROJECT_META['packages']:
        ver = PROJECT_META['packages'][package_name]['version']
        if check_version(ver, version):
            return True
    return False

def installed_packages():
    ip = []
    for package_name in PROJECT_META['packages']:
        ip.append(package_name)
    return ip

def download_package(package_name, version):
    files = package_files(package_name, version)
    if files is None:
        print_error('Can not get file list for package "{}" with version "{}"'.format(package_name, version))
        return
    home = package_home(package_name, version, True)
    for f in files:
        fname = f['name']
        if os.path.exists(os.path.join(home, fname)):
            print_warning('File exists {}'.format(fname))
        else:
            url = "https://dl.bintray.com/{0}/{1}/{2}".format(SUBJECT, REPO, f['path'])
            path = download(url, fname, home)

def parse_version(ver):
    return tuple(map(int, (ver.split("."))))

def check_version(v1, v2):
    return parse_version(v1) >= parse_version(v2)

def latest_version(package_name):
    if package_name in STORAGE:
        info = STORAGE[package_name]
        return info['latest_version']
    return None

def get_package_meta(package_name, version, download=False):
    home = package_home(package_name, version)
    pmeta = os.path.join(home, '{}_{}_meta.json'.format(package_name, version))
    if not os.path.exists(pmeta):
        if download:
            # download plugin into local repository
            download_package(package_name, version)
        else:
            return None
    package_meta = None
    try:
        package_meta = json.loads(pathlib.Path(pmeta).read_text())
    except FileNotFoundError:
        print_error('Can not find {}@{}'.format(package_name, version))
        return None
    return package_meta
            
def install_package(package_name, version = None):
    if version == None or version == '':
        version = latest_version(package_name)
        if version is None:
            print_error('Not found latest version for package "{0}"'.format(package_name))
            return False
    if is_package_installed(package_name, version) and not FORCE:
        print_bold('Found installed {}@{}'.format(package_name, ver))
        return True
    home = package_home(package_name, version)
    package_meta = get_package_meta(package_name, version, True)
    if package_meta is None:
        print_error('Can not find {}@{}'.format(package_name, version))
        return False
    deps = []
    if 'dependencies' in package_meta:
        deps.extend(package_meta['dependencies'])
    for platform in PLATFORMS:
        if platform == 'all':
            continue
        if 'ios' in PLATFORMS and 'platform_{}'.format(platform) in package_meta:
            pl = package_meta['platform_{}'.format(platform)]
            if 'dependencies' in pl:
                deps.extend(pl['dependencies'])
    if len(deps) > 0:
        print('Checking project dependencies: ' + ', '.join(deps))
    for dep in deps:
        p, v = split_package_name(dep)
        if not install_package(p, v):
            print_error('Can not install dependency: {}'.format(dep))
            if not FORCE:
                return False
    print_bold('Installing {}@{}'.format(package_name, version))
    processed_platforms = []
    all_files = []
    for pl in PLATFORMS:
        tarname = '{}_{}_{}.tgz'.format(package_name, version, pl)
        tarpath = os.path.join(home, tarname)
        if os.path.exists(tarpath):
            processed_platforms.append(pl)
            print('  Unpack {}'.format(tarname))
            with tarfile.open(tarpath, mode="r:*") as tar:
                #tar.extractall()
                tarinfo = tar.next()
                while not tarinfo is None:
                    fn = str(tarinfo.name)
                    if not fn in all_files:
                        all_files.append(fn)
                    if tarinfo.isfile() and os.path.exists(fn) and not OVERWRITE:
                        print_warning('{} already exists'.format(tarinfo.name))
                    else:
                        tar.extract(tarinfo)
                    tarinfo = tar.next()
    PROJECT_META['packages'][package_name] = {"version": version, "platforms": processed_platforms, "dependencies": deps}
    save_project_meta()
    # save install journal
    j_home = journal_home()
    with open(os.path.join(j_home, '{}@{}'.format(package_name, version)), 'w') as f:
        json.dump(all_files, f)
    return True

def prepare_project():
    if not os.path.exists('project.godot'):
        print_error('Godot project not found in current directory')
        exit()
    load_project_meta()

def list_installed_packages():
    print_bold('Default platforms: ' + ', '.join(PLATFORMS))
    print()
    for p in installed_packages():
        info = PROJECT_META['packages'][p]
        print_bold('{}@{}'.format(p, info['version']))
        print('  platforms: ' + ', '.join(info['platforms']))
        print()

def copyfiles(src, dst, overwrite=False):
    if not os.path.isdir(src):
        try:
            path = os.path.dirname(dst)
            basename = os.path.basename(dst)
            if basename == '':
                basename = os.path.basename(src)
            dst = os.path.join(path, basename)
            if os.path.exists(dst) and not overwrite:
                print_warning('File exists {}'.format(dst))
                return
            try:
                os.makedirs(path)
            except FileExistsError:
                pass
            shutil.copy2(src, dst)
        except OSError as e:
            print(e)
            traceback.print_stack()
        return
    # process directory
    try:
        os.makedirs(dst)
    except FileExistsError:
        pass
    for item in os.listdir(src):
        try:
            s = os.path.join(src, item)
            d = os.path.join(dst, item)
            copyfiles(s, d, overwrite)
        except OSError as e:
            print(e)
            traceback.print_stack()

def prepare_arch(meta, path):
    if 'dependencies' in meta:
        newdeps = []
        for d in meta['dependencies']:
            p, v = split_package_name(d)
            if not p in STORAGE:
                err = 'Dependency {} not found'.format(p)
                if FORCE:
                    print_warning(err)
                else:
                    print_error(err)
                    exit()
            info = STORAGE[p]
            if v is None:
                v = info['latest_version']
                print('Using version {} for dependency {}'.format(v, p))
            else:
                if not v in info['versions']:
                    err = 'Dependency {}@{} not found'.format(p, v)
                    if FORCE:
                        print_warning(err)
                    else:
                        print_error(err)
                        exit()
            newdeps.append('{}@{}'.format(p, v))
        meta['dependencies'] = newdeps
    if 'files' in meta:
        try:
            os.makedirs(path)
        except FileExistsError:
            pass
        copy = meta.pop('files')
        for key in copy:
            dst = os.path.join(path, copy[key])
            copyfiles(key, dst, OVERWRITE)
        return True
    return False

def pack_tarball(tarname, path):
    tar = tarfile.open(tarname, mode="w:gz")
    for item in os.listdir(path):
        it = os.path.join(path, item)
        tar.add(it, item)
    tar.close()
    print('Packed {}'.format(tarname))

def pack_plugin(path):
    meta = {}
    try:
        meta_str = pathlib.Path(os.path.join(path, 'nativelib.json')).read_text()
        meta = json.loads(meta_str)
    except FileNotFoundError:
        print_error('Plugin not found at path "{}"'.format(path))
        return
    package_name = meta['name']
    package_version = meta['version']
    home = package_home(package_name, package_version, True)
    h_all = os.path.join(home, 'all')
    files = []
    if prepare_arch(meta, h_all):
        fname = '{}_{}_all.tgz'.format(package_name, package_version)
        pack_tarball(os.path.join(home, fname), h_all)
        files.append(fname)
        if CLEANUP:
            try:
                shutil.rmtree(h_all)
            except OSError as e:
                print_error(e)
    if 'platform_ios' in meta:
        h = os.path.join(home, 'ios')
        if prepare_arch(meta['platform_ios'], h):
            fname = '{}_{}_ios.tgz'.format(package_name, package_version)
            pack_tarball(os.path.join(home, fname), h)
            files.append(fname)
            if CLEANUP:
                try:
                    shutil.rmtree(h)
                except OSError as e:
                    print_error(e)
    if 'platform_android' in meta:
        h = os.path.join(home, 'android')
        if prepare_arch(meta['platform_android'], h):
            fname = '{}_{}_android.tgz'.format(package_name, package_version)
            pack_tarball(os.path.join(home, fname), h)
            files.append(fname)
            if CLEANUP:
                try:
                    shutil.rmtree(h)
                except OSError as e:
                    print_error(e)
    fname = '{}_{}_meta.json'.format(package_name, package_version)
    with open(os.path.join(home, fname), 'w') as f:
        json.dump(meta, f)
    files.append(fname)
    # save package into repo
    if not package_name in STORAGE:
        STORAGE[package_name] = {'name': package_name, 'description': meta['description']}
    st_info = STORAGE[package_name]
    st_info['latest_version'] = package_version
    st_info['updated'] = time.strftime('%Y-%m-%dT%T%Z', time.gmtime())
    if not 'versions' in st_info:
        st_info['versions'] = {}
    st_vers = st_info['versions']
    f_info = []
    for fn in files:
        f_info.append({'name': fn})
    st_vers[package_version] = f_info
    save_storage()

def load_storage():
    global STORAGE
    try:
        filename = os.path.join(str(pathlib.Path.home()), ".nativelib", "storage")
        meta_str = pathlib.Path(filename).read_text()
        meta = json.loads(meta_str)
        STORAGE = meta
    except FileNotFoundError as e:
        STORAGE = {}
        print_bold('Updating repository')
        update_repo()

def save_storage():
    path = os.path.join(str(pathlib.Path.home()), ".nativelib")
    if not os.path.exists(path):
        os.makedirs(path)
    filename = os.path.join(path, "storage")
    with open(filename, 'w') as f:
        json.dump(STORAGE, f, indent=2)

def update_repo():
    repo = get_packages()
    num = 0
    for p in repo:
        package_name = p['name']
        if not package_name in STORAGE:
            STORAGE[package_name] = {}
        info = get_package_info(package_name)
        st_info = STORAGE[package_name]
        st_info['name'] = info['name']
        st_info['description'] = info['desc']
        st_info['latest_version'] = info['latest_version']
        st_info['updated'] = info['updated']
        if not 'versions' in st_info:
            st_info['versions'] = {}
        st_vers = st_info['versions']
        for ver in info['versions']:
            files = package_files(package_name, ver)
            file_info = []
            for f in files:
                url = "https://dl.bintray.com/{0}/{1}/{2}".format(SUBJECT, REPO, f['path'])
                fi = {'name': f['name'], 'url': url}
                file_info.append(fi)
            st_vers[ver] = file_info
        num += 1
    save_storage()
    print_bold('Updated {} packages info'.format(num))

def search_in_repo(pattern):
    for package_name in STORAGE:
        if pattern in package_name:
            print_bold('{}@{}'.format(package_name, STORAGE[package_name]['latest_version']))

def info_from_repo(package_name, version=None):
    if package_name in STORAGE:
        info = STORAGE[package_name]
        if version is None:
            version = info['latest_version']
        if not version in info['versions']:
            print_error('Package "{0}" with version "{1}" not found'.format(package_name, version))
            return
        files = info['versions'][version]
        print_bold('{}@{}'.format(package_name, version))
        print('  description: {}'.format(info['description']))
        print('  updated: {}'.format(info['updated']))
        archs = []
        for f in files:
            pts = f['name'].split('_')
            tail = pts[-1]
            ar = tail.split('.')
            if ar[0] == 'meta':
                continue
            archs.append(ar[0])
        print('  platforms: ' + ', '.join(archs))
        package_meta = get_package_meta(package_name, version)
        if not package_meta is None:
            # show dependencies
            if 'dependencies' in package_meta:
                print('  dependencies: ' + ', '.join(package_meta['dependencies']))
            if 'platform_ios' in package_meta:
                meta_ios = package_meta['platform_ios']
                if 'dependencies' in meta_ios:
                    print('  dependencies for iOS: ' + ', '.join(meta_ios['dependencies']))
            if 'platform_android' in package_meta:
                meta_android = package_meta['platform_android']
                if 'dependencies' in meta_android:
                    print('  dependencies for Android: ', ', '.join(meta_android['dependencies']))
    else:
        print_error('Package "{0}" with version "{1}" not found'.format(*args))

def uninstall_package(package_name):
    if not package_name in PROJECT_META['packages']:
        print_warning('{} not installed'.format(package_name))
        return
    info = PROJECT_META['packages'].pop(package_name)
    version = info['version']
    for pack in installed_packages():
        if pack == package_name:
            continue
        deps = PROJECT_META['packages'][pack]['dependencies']
        for d in deps:
            p, v = split_package_name(d)
            if p == package_name:
                err = '{} depends on {}'.format(pack, package_name)
                if FORCE:
                    print_warning(err)
                else:
                    print_error(err)
                    return
    j_home = journal_home()
    journal = os.path.join(j_home, '{}@{}'.format(package_name, version))
    J = []
    try:
        _str = pathlib.Path(journal).read_text()
        J = json.loads(_str)
    except FileNotFoundError as e:
        print_error('Can not find installation journal for {}@{}'.format(package_name, version))
        exit()
    dirs = []
    for fn in J:
        if os.path.isdir(fn):
            dirs.append(fn)
        elif os.path.exists(fn):
            os.remove(fn)
    for d in reversed(dirs):
        try:
            os.rmdir(d)
        except OSError:
            pass
    save_project_meta()
    os.remove(journal)
    print_bold('{} uninstalled'.format(package_name))

def install_required_packages():
    global FORCE
    force = FORCE
    FORCE = True
    for package_name in installed_packages():
        info = PROJECT_META['packages'][package_name]
        deps = info['dependencies']
        for d in deps:
            p, v = split_package_name(d)
            if not is_package_installed(p, v):
                install_package(p, v)
        ver = info['version']
        j_home = journal_home()
        journal = os.path.join(j_home, '{}@{}'.format(package_name, ver))
        if not os.path.exists(journal):
            install_package(package_name, ver)
    FORCE = force

def print_help():
    print("""
Usage: nativelib [options] [command]

Repository related commands:
    -s|--search <pattern>\tSearch packages in repository
    -I|--info <package>\t\tShow details about specific package
    -U|--update\t\t\tUpdate repository info
    -P|--pack <path>\t\tPack the plugin in specific path into local repository

Repository related options:
    -C|--no-cleanup\t\tDon't remove temporary files

Project related commands:
    -i|--install <package>\tInstall package
    -u|--uninstall <package>\tUninstall package
    -l|--list\t\t\tList installed packages
    -p|--prepare\t\tPrepare project on new machine (install all required packages)

Project related options:
    --ios\t\t\tProcess iOS platform (also add iOS to project's platform list)
    --android\t\t\tProcess Android platform (also add Android to project's platform list)
    -o|--overwrite\t\tOverwrite files during installation

Other commands:
    -h|--help\t\t\tPrints this page

Other options:
    -f|--force\t\t\tIgnore errors and warnings if possible

Version: {}
""".format(VERSION))
    
try:
    args = sys.argv[1:]
    options, tail = getopt.getopt(args, "s:I:UP:Ci:u:lpohf", [
        "search=", "info=", "update", "pack=",
        "no-cleanup",

        "install=", "uninstall=", "list", "prepare",
        "ios", "android", "overwrite",

        "help",
        "force"])

    if len(tail) > 0:
        for p in tail:
            print_error('Unrecognized parameter: {0}'.format(p))

    load_storage()

    for op in options:
        par = op[0]
        arg = op[1]
        # Repository commands
        if par == '-s' or par == '--search':
            search_in_repo(arg)
            exit()
        elif par == '-I' or par == '--info':
            p, v = split_package_name(arg)
            info_from_repo(p, v)
            exit()
        elif par == '-U' or par == '--update':
            update_repo()
            exit()
        elif par == '-P' or par == '--pack':
            pack_plugin(arg)
            exit()

        # Repository options
        elif par == '-C' or par == '--no-cleanup':
            CLEANUP = False

        # Project commands
        elif par == '-i' or par == '--install':
            if PROJECT_META is None:
                prepare_project()
            p, v = split_package_name(arg)
            install_package(p, v)
            exit()
        elif par == '-u' or par == '--uninstall':
            if PROJECT_META is None:
                prepare_project()
            uninstall_package(arg)
            exit()
        elif par == '-l' or par == '--list':
            if PROJECT_META is None:
                prepare_project()
            list_installed_packages()
            exit()
        elif par == '-p' or par == '--prepare':
            if PROJECT_META is None:
                prepare_project()
            install_required_packages()

        # Project options
        elif par == '--ios':
            if PROJECT_META is None:
                prepare_project()
            if not 'ios' in PLATFORMS:
                PLATFORMS.append('ios')
                save_project_meta()
        elif par == '--android':
            if PROJECT_META is None:
                prepare_project()
            if not 'android' in PLATFORMS:
                PLATFORMS.append('android')
                save_project_meta()
        elif par == '-o' or par == '--overwrite':
            OVERWRITE = True

        # Other commands
        elif par == '-h' or par == '--help':
            print_help()
            exit()

        # Other options
        elif par == '-f' or par == '--force':
            FORCE = True

except getopt.GetoptError as ex:
    print_error(ex)
