#!/usr/bin/env python

# -*- coding: UTF-8 -*-
from __future__ import unicode_literals

import sys, os, getopt, json, shutil, traceback, tarfile, time, uuid, base64, datetime
if sys.version_info[0] >= 3:
    from urllib.request import Request, urlopen, urlretrieve
    from urllib.error import HTTPError
    import pathlib
else:
    from urllib2 import urlopen, Request
    from urllib2 import HTTPError
    from urllib import urlretrieve
import pprint

VERSION = "0.1.6"
API = "https://api.bintray.com"
SUBJECT = "mobilap"
REPO = "nativelib"
FORCE = False
OVERWRITE = False
CLEANUP = True
PROJECT = None
PROJECT_META = None
AUTH_HEADER = None
STORAGE = {}
PLATFORMS = []
INTERACTIVE = sys.stdout.isatty()

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

#################################
#
# Utilities
#

def print_error(e):
    if INTERACTIVE:
        print('{0}{2}{1}'.format(bcolors.FAIL, bcolors.ENDC, e))
    else:
        print(e)

def print_warning(w):
    if INTERACTIVE:
        print('{0}{2}{1}'.format(bcolors.WARNING, bcolors.ENDC, w))
    else:
        print(w)

def print_bold(s):
    if INTERACTIVE:
        print('{0}{2}{1}'.format(bcolors.BOLD, bcolors.ENDC, s))
    else:
        print(s)

def show_custom_info(info):
    pprint.pprint(info)

def parse_version(ver):
    return tuple(map(int, (ver.split("."))))

def check_version(v1, v2):
    return parse_version(v1) >= parse_version(v2)

def file_bytes(filepath):
    if sys.version_info[0] >= 3:
        return pathlib.Path(filepath).read_bytes()
    else:
        with open(filepath, 'rb') as f:
            return f.read()

def file_text(filepath):
    if sys.version_info[0] >= 3:
        return pathlib.Path(filepath).read_text()
    else:
        with open(filepath, 'r') as f:
            return f.read()

def home_path():
    if sys.version_info[0] >= 3:
        return str(pathlib.Path.home())
    else:
        return os.path.expanduser("~")

def copyfiles(src, dst, overwrite=False):
    if not os.path.isdir(src):
        try:
            path = os.path.dirname(dst)
            basename = os.path.basename(dst)
            if basename == '':
                basename = os.path.basename(src)
            dst = os.path.join(path, basename)
            if os.path.exists(dst) and not overwrite:
                print_warning('File exists {}'.format(dst))
                return
            try:
                os.makedirs(path)
            except OSError:
                pass
            shutil.copy2(src, dst)
        except OSError as e:
            print(e)
            traceback.print_stack()
        return
    # process directory
    try:
        os.makedirs(dst)
    except OSError:
        pass
    for item in os.listdir(src):
        try:
            s = os.path.join(src, item)
            d = os.path.join(dst, item)
            copyfiles(s, d, overwrite)
        except OSError as e:
            print(e)
            traceback.print_stack()

#################################
#
# Bintray API Methods
#

def get_packages():
    try:
        req = Request("{0}/repos/{1}/{2}/packages".format(API, SUBJECT, REPO))
        if not AUTH_HEADER is None:
            req.add_header('Authorization', AUTH_HEADER)
        contents = urlopen(req).read()
        return json.loads(contents)
    except HTTPError as e:
        print_error(e)
        return None

def get_package_info(package_name):
    try:
        req = Request("{0}/packages/{1}/{2}/{3}".format(API, SUBJECT, REPO, package_name))
        if not AUTH_HEADER is None:
            req.add_header('Authorization', AUTH_HEADER)
        contents = urlopen(req).read()
        return json.loads(contents)
    except HTTPError as e:
        print_error(e)
        return None

def search_packages(name):
    try:
        req = Request("{0}/search/packages?name={3}&subject={1}&repo={2}".format(API, SUBJECT, REPO, name))
        if not AUTH_HEADER is None:
            req.add_header('Authorization', AUTH_HEADER)
        contents = urlopen(req).read()
        return json.loads(contents)
    except HTTPError as e:
        print_error(e)
        return None

def package_version_info(package_name, version = None):
    if version == None or version == '':
        version = '_latest'
    try:
        req = Request("{0}/packages/{1}/{2}/{3}/versions/{4}".format(API, SUBJECT, REPO, package_name, version))
        if not AUTH_HEADER is None:
            req.add_header('Authorization', AUTH_HEADER)
        contents = urlopen(req).read()
        return json.loads(contents)
    except HTTPError as e:
        print_error(e)
        return None

def upload_file(package_name, version, filepath):
    try:
        fname = os.path.basename(filepath)
        data = file_bytes(filepath)
        req = Request("{0}/content/{1}/{2}/{3}".format(API, SUBJECT, REPO, fname), data=data, method='PUT')
        if AUTH_HEADER is None:
            print_error('Uploading requires authenticated user')
            return
        else:
            req.add_header('Authorization', AUTH_HEADER)
            req.add_header('X-Bintray-Package', package_name)
            req.add_header('X-Bintray-Version', version)
            req.add_header('X-Bintray-Publish', 1)
            if OVERWRITE:
                req.add_header('X-Bintray-Override', 1)
        result = urlopen(req).read()
        return result
    except HTTPError as e:
        print_error(e)
        return None

def package_files(package_name, version = None):
    try:
        url = ''
        if version is None:
            url = "{0}/packages/{1}/{2}/{3}/files".format(API, SUBJECT, REPO, package_name)
        else:
            url = "{0}/packages/{1}/{2}/{3}/versions/{4}/files".format(API, SUBJECT, REPO, package_name, version)
        req = Request(url)
        if not AUTH_HEADER is None:
            req.add_header('Authorization', AUTH_HEADER)
        contents = urlopen(req).read()
        return json.loads(contents)
    except HTTPError as e:
        print_error(e)
        return None

def create_package(package_name, description, license, vcs_url):
    try:
        info = {
            "name": package_name,
            "desc": description,
            "licenses": [license],
            "vcs_url": vcs_url
        }
        data = json.dumps(info).encode('utf-8')
        req = Request('{0}/packages/{1}/{2}'.format(API, SUBJECT, REPO), data=data, method='POST')
        if not AUTH_HEADER is None:
            req.add_header('Authorization', AUTH_HEADER)
        req.add_header('Content-Type', 'application/json')
        contents = urlopen(req).read()
        return contents
    except HTTPError as e:
        print_error(e)
        return None

def create_version(package_name, version):
    try:
        info = {
            "name": version,
            "released": datetime.datetime.utcnow().isoformat()
        }
        data = json.dumps(info).encode('utf-8')
        req = Request('{0}/packages/{1}/{2}/{3}/versions'.format(API, SUBJECT, REPO, package_name), data=data, method='POST')
        if not AUTH_HEADER is None:
            req.add_header('Authorization', AUTH_HEADER)
        req.add_header('Content-Type', 'application/json')
        contents = urlopen(req).read()
        return contents
    except HTTPError as e:
        print_error(e)
        return None
    
def load_credentials():
    filename = os.path.join(home_path(), ".nativelib", "local.properties")
    if os.path.exists(filename):
        user = None
        apikey = None
        content = file_text(filename)
        for line in content.split('\n'):
            if line.startswith('bintray.user'):
                p = line.split('=')
                user = p[1]
            elif line.startswith('bintray.apikey'):
                p = line.split('=')
                apikey = p[1]
        if not user is None and not apikey is None:
            key = '{}:{}'.format(user, apikey)
            encoded = base64.b64encode(key.encode("utf-8"))
            global AUTH_HEADER
            AUTH_HEADER = 'Basic {}'.format(str(encoded, "utf-8"))
            return True
    return False

#################################
#
# Public Methods
#

#################################
# Work with local storage

def storage_load():
    global STORAGE
    try:
        filename = os.path.join(home_path(), ".nativelib", "storage")
        meta_str = file_text(filename)
        meta = json.loads(meta_str)
        STORAGE = meta
    except IOError as e:
        STORAGE = {}
        print_bold('Updating repository')
        storage_update()

def storage_save():
    path = os.path.join(home_path(), ".nativelib")
    if not os.path.exists(path):
        os.makedirs(path)
    filename = os.path.join(path, "storage")
    with open(filename, 'w') as f:
        json.dump(STORAGE, f, indent=2)

def storage_update():
    repo = get_packages()
    num = 0
    for p in repo:
        package_name = p['name']
        if not package_name in STORAGE:
            STORAGE[package_name] = {}
        info = get_package_info(package_name)
        st_info = STORAGE[package_name]
        st_info['name'] = info['name']
        st_info['description'] = info['desc']
        st_info['latest_version'] = info['latest_version']
        st_info['updated'] = info['updated']
        st_info['url'] = info['vcs_url']
        st_info['license'] = info['licenses'][0]
        if not 'versions' in st_info:
            st_info['versions'] = {}
        st_vers = st_info['versions']
        for ver in info['versions']:
            files = package_files(package_name, ver)
            file_info = []
            for f in files:
                url = "https://dl.bintray.com/{0}/{1}/{2}".format(SUBJECT, REPO, f['path'])
                fi = {'name': f['name'], 'url': url}
                file_info.append(fi)
            st_vers[ver] = file_info
        num += 1
    storage_save()
    print_bold('Updated {} packages info'.format(num))

def storage_search(pattern):
    for package_name in STORAGE:
        if pattern in package_name:
            print_bold('{}@{}'.format(package_name, STORAGE[package_name]['latest_version']))

def storage_info(package_name, version=None):
    if package_name in STORAGE:
        info = STORAGE[package_name]
        if version is None:
            version = info['latest_version']
        if not version in info['versions']:
            print_error('Package "{0}" with version "{1}" not found'.format(package_name, version))
            return
        files = info['versions'][version]
        print_bold('{}@{}'.format(package_name, version))
        print('  description: {}'.format(info['description']))
        print('  updated: {}'.format(info['updated']))
        archs = []
        for f in files:
            pts = f['name'].split('_')
            tail = pts[-1]
            ar = tail.split('.')
            if ar[0] == 'meta':
                continue
            archs.append(ar[0])
        print('  platforms: ' + ', '.join(archs))
        package_meta = get_package_meta(package_name, version)
        if not package_meta is None:
            # show dependencies
            if 'dependencies' in package_meta:
                print('  dependencies: ' + ', '.join(package_meta['dependencies']))
            if 'platform_ios' in package_meta:
                meta_ios = package_meta['platform_ios']
                if 'dependencies' in meta_ios:
                    print('  dependencies for iOS: ' + ', '.join(meta_ios['dependencies']))
            if 'platform_android' in package_meta:
                meta_android = package_meta['platform_android']
                if 'dependencies' in meta_android:
                    print('  dependencies for Android: ', ', '.join(meta_android['dependencies']))
    else:
        print_error('Package "{0}" with version "{1}" not found'.format(*args))

def latest_version(package_name):
    if package_name in STORAGE:
        info = STORAGE[package_name]
        return info['latest_version']
    return None

#################################
# Work with packages
        
def package_home(package_name, version, create=False):
    home = home_path()
    path = os.path.join(home, ".nativelib", "packages", package_name, version)
    if create:
        try:
            os.makedirs(path)
        except OSError:
            pass
    return path

def journal_home():
    if PROJECT_META is None:
        return None
    home = home_path()
    path = os.path.join(home, '.nativelib', 'projects', PROJECT_META['id'])
    if not os.path.exists(path):
        os.makedirs(path)
    return path

def download(url, filename, path):
    def _progress(count, block_size, total_size):
        done = int(100*(count*block_size)/total_size)
        if done > 100:
            done = 100
        d = int(done/10)
	if INTERACTIVE:
            sys.stdout.write('\r{}\t[{}{}] {}%'.format(filename, '=' * d, '.' * (10-d), done))
            #sys.stdout.write('\r{}\t{}%'.format(filename, done))
            sys.stdout.flush()
    (filepath, headers) = urlretrieve(url, os.path.join(path, filename), reporthook=_progress)
    if INTERACTIVE:
	sys.stdout.write('\n')
    else:
	print('Downloaded {}'.format(filename))
    return filepath

def split_package_name(package_name):
    p = package_name
    v = None
    if '@' in p:
        pk = p.split('@')
        p = pk[0]
        v = pk[1]
    return p, v

def download_package(package_name, version):
    files = package_files(package_name, version)
    if files is None:
        print_error('Can not get file list for package "{}" with version "{}"'.format(package_name, version))
        return
    home = package_home(package_name, version, True)
    for f in files:
        fname = f['name']
        if os.path.exists(os.path.join(home, fname)):
            print_warning('File exists {}'.format(fname))
        else:
            url = "https://dl.bintray.com/{0}/{1}/{2}".format(SUBJECT, REPO, f['path'])
            path = download(url, fname, home)

def get_package_meta(package_name, version, download=False):
    home = package_home(package_name, version)
    pmeta = os.path.join(home, '{}_{}_meta.json'.format(package_name, version))
    if not os.path.exists(pmeta):
        if download:
            # download plugin into local repository
            download_package(package_name, version)
        else:
            return None
    package_meta = None
    try:
        package_meta = json.loads(file_text(pmeta))
    except IOError:
        print_error('Can not find {}@{}'.format(package_name, version))
        return None
    return package_meta
            
def prepare_arch(meta, path):
    if 'dependencies' in meta:
        newdeps = []
        for d in meta['dependencies']:
            p, v = split_package_name(d)
            if not p in STORAGE:
                err = 'Dependency {} not found'.format(p)
                if FORCE:
                    print_warning(err)
                else:
                    print_error(err)
                    exit()
            info = STORAGE[p]
            if v is None:
                v = info['latest_version']
                print('Using version {} for dependency {}'.format(v, p))
            else:
                if not v in info['versions']:
                    err = 'Dependency {}@{} not found'.format(p, v)
                    if FORCE:
                        print_warning(err)
                    else:
                        print_error(err)
                        exit()
            newdeps.append('{}@{}'.format(p, v))
        meta['dependencies'] = newdeps
    if 'files' in meta:
        try:
            os.makedirs(path)
        except OSError:
            pass
        copy = meta.pop('files')
        for key in copy:
            dst = os.path.join(path, copy[key])
            copyfiles(key, dst, OVERWRITE)
        return True
    return False

def pack_tarball(tarname, path):
    tar = tarfile.open(tarname, mode="w:gz")
    for item in os.listdir(path):
        it = os.path.join(path, item)
        tar.add(it, item)
    tar.close()
    print('Packed {}'.format(tarname))

def pack_plugin(path):
    meta = {}
    try:
        meta_str = file_text(os.path.join(path, 'nativelib.json'))
        meta = json.loads(meta_str)
    except IOError:
        print_error('Plugin not found at path "{}"'.format(path))
        return None
    package_name = meta['name']
    package_version = meta['version']
    home = package_home(package_name, package_version, True)
    h_all = os.path.join(home, 'all')
    files = []
    if prepare_arch(meta, h_all):
        fname = '{}_{}_all.tgz'.format(package_name, package_version)
        pack_tarball(os.path.join(home, fname), h_all)
        files.append(fname)
        if CLEANUP:
            try:
                shutil.rmtree(h_all)
            except OSError as e:
                print_error(e)
    if 'platform_ios' in meta:
        h = os.path.join(home, 'ios')
        if prepare_arch(meta['platform_ios'], h):
            fname = '{}_{}_ios.tgz'.format(package_name, package_version)
            pack_tarball(os.path.join(home, fname), h)
            files.append(fname)
            if CLEANUP:
                try:
                    shutil.rmtree(h)
                except OSError as e:
                    print_error(e)
    if 'platform_android' in meta:
        h = os.path.join(home, 'android')
        if prepare_arch(meta['platform_android'], h):
            fname = '{}_{}_android.tgz'.format(package_name, package_version)
            pack_tarball(os.path.join(home, fname), h)
            files.append(fname)
            if CLEANUP:
                try:
                    shutil.rmtree(h)
                except OSError as e:
                    print_error(e)
    fname = '{}_{}_meta.json'.format(package_name, package_version)
    with open(os.path.join(home, fname), 'w') as f:
        json.dump(meta, f)
    files.append(fname)
    # save package into repo
    if not package_name in STORAGE:
        STORAGE[package_name] = {
            'name': package_name,
            'description': meta['description'],
            'license': meta['license'],
            'url': meta['url']
        }
    st_info = STORAGE[package_name]
    st_info['latest_version'] = package_version
    st_info['updated'] = datetime.datetime.utcnow().isoformat() # time.strftime('%Y-%m-%dT%T%Z', time.gmtime())
    if not 'versions' in st_info:
        st_info['versions'] = {}
    st_vers = st_info['versions']
    f_info = []
    for fn in files:
        f_info.append({'name': fn})
    st_vers[package_version] = f_info
    storage_save()
    return '{}@{}'.format(package_name, package_version)

def publish_plugin(path):
    pv = pack_plugin(path)
    if pv is None:
        return
    package_name, version = split_package_name(pv)
    if not package_name in STORAGE:
        print_error('Package "{}" not found'.format(package_name))
        return
    info = STORAGE[package_name]
    if not version in info['versions']:
        print_error('Package "{0}" with version "{1}" not found'.format(package_name, version))
        return
    files = info['versions'][version]
    home = package_home(package_name, version)
    package_info = get_package_info(package_name)
    if package_info is None:
        # create package
        print_bold('Create package {}'.format(package_name))
        if not create_package(package_name, info['description'], info['license'], info['url']) is None:
            print('OK')
    version_info = package_version_info(package_name, version)
    if version_info is None:
        # create version
        print_bold('Create version {} for package {}'.format(version, package_name))
        if not create_version(package_name, version) is None:
            print('OK')
    for fn in files:
        fname = fn['name']
        print_bold('Upload {}'.format(fname))
        fpath = os.path.join(home, fname)
        if not upload_file(package_name, version, fpath) is None:
            print('OK')

#################################
# Work with project

def prepare_project():
    if not os.path.exists('project.godot'):
        print_error('Godot project not found in current directory')
        exit()
    load_project()
    load_project_meta()

def load_project():
    global PROJECT
    try:
        pr_str = file_text('project.godot')
        PROJECT = pr_str.split('\n')
    except IOError as e:
        PROJECT = []

def save_project():
    with open('project.godot', 'w') as f:
        f.write('\n'.join(PROJECT))

def project_section(section):
    sec = []
    found = False
    key = '[{}]'.format(section)
    for line in PROJECT:
        if line == key:
            found = True
        elif line.startswith('['):
            found = False
        elif found and line != '':
            sec.append(line)
    return sec

def project_set(section, key, value):
    found = False
    sk = '[{}]'.format(section)
    kk = '{}='.format(key)
    for idx, line in enumerate(PROJECT):
        if line == sk:
            found = True
        elif line.startswith('['):
            if found:
                # append key to section
                PROJECT.insert(idx-1, '{}={}'.format(key, value))
                save_project()
                return
        elif found and line.startswith(kk):
            # change value for existing key
            PROJECT[idx] = '{}={}'.format(key, value)
            return
    # append section and key
    if not found:
        PROJECT.append('')
        PROJECT.append(sk)
        PROJECT.append('')
    PROJECT.append('{}={}'.format(key, value))
    save_project()

def project_get(section, key):
    found = False
    sk = '[{}]'.format(section)
    kk = '{}='.format(key)
    for line in PROJECT:
        if line == sk:
            found = True
        elif line.startswith('['):
            if found:
                return None
        elif found and line.startswith(kk):
            pp = line.split('=')
            return pp[1]
    return None

def project_del(section, key):
    found = False
    sk = '[{}]'.format(section)
    kk = '{}='.format(key)
    for idx, line in enumerate(PROJECT):
        if line == sk:
            found = True
        elif line.startswith('['):
            if found:
                return False
        elif found and line.startswith(kk):
            PROJECT.pop(idx)
            save_project()
            return True
    return False

def project_list_add(section, key, value):
    vals = project_get(section, key)
    if not vals is None:
        vals = json.loads(vals)
        if vals == '':
            vals = []
        else:
            vals = vals.split(',')
    else:
        vals = []
    if value in vals:
        return
    vals.append(value)
    vals = ','.join(vals)
    project_set(section, key, '"{}"'.format(vals))
    save_project()

def project_list_rm(section, key, value):
    vals = project_get(section, key)
    if not vals is None:
        vals = json.loads(vals)
        vals = vals.split(',')
    else:
        return
    vals.remove(value)
    vals = ','.join(vals)
    project_set(section, key, '"{}"'.format(vals))
    save_project()

def load_project_meta():
    global PROJECT_META
    global PLATFORMS
    try:
        meta_str = file_text('.nativelib')
        meta = json.loads(meta_str)
        PROJECT_META = meta
    except IOError as e:
        PROJECT_META = {
            'id': str(uuid.uuid4()),
            'platforms': ['all'],
            'packages': {}
        }
        save_project_meta()
    PLATFORMS = PROJECT_META['platforms']

def save_project_meta():
    with open('.nativelib', 'w') as f:
        json.dump(PROJECT_META, f, indent = 4)

def is_package_installed(package_name, version):
    if package_name in PROJECT_META['packages']:
        ver = PROJECT_META['packages'][package_name]['version']
        if check_version(ver, version):
            return True
    return False

def installed_packages():
    ip = []
    for package_name in PROJECT_META['packages']:
        ip.append(package_name)
    return ip

def list_installed_packages():
    print_bold('Default platforms: ' + ', '.join(PLATFORMS))
    print('')
    for p in installed_packages():
        info = PROJECT_META['packages'][p]
        print_bold('{}@{}'.format(p, info['version']))
        print('  platforms: ' + ', '.join(info['platforms']))
        print('')

def install_package(package_name, version = None):
    if version == None or version == '':
        version = latest_version(package_name)
        if version is None:
            print_error('Not found latest version for package "{0}"'.format(package_name))
            return False
    if is_package_installed(package_name, version) and not FORCE:
        print_bold('Found installed {}@{}'.format(package_name, version))
        return True
    home = package_home(package_name, version)
    package_meta = get_package_meta(package_name, version, True)
    if package_meta is None:
        print_error('Can not find {}@{}'.format(package_name, version))
        return False
    deps = []
    if 'dependencies' in package_meta:
        deps.extend(package_meta['dependencies'])
    for platform in PLATFORMS:
        if platform == 'all':
            continue
        if platform in PLATFORMS and 'platform_{}'.format(platform) in package_meta:
            pl = package_meta['platform_{}'.format(platform)]
            if 'dependencies' in pl:
                deps.extend(pl['dependencies'])
    if len(deps) > 0:
        print('Checking project dependencies: ' + ', '.join(deps))
    for dep in deps:
        p, v = split_package_name(dep)
        if not install_package(p, v):
            print_error('Can not install dependency: {}'.format(dep))
            if not FORCE:
                return False
    print_bold('Installing {}@{}'.format(package_name, version))
    processed_platforms = []
    all_files = []
    for pl in PLATFORMS:
        tarname = '{}_{}_{}.tgz'.format(package_name, version, pl)
        tarpath = os.path.join(home, tarname)
        if os.path.exists(tarpath):
            processed_platforms.append(pl)
            print('  Unpack {}'.format(tarname))
            with tarfile.open(tarpath, mode="r:*") as tar:
                #tar.extractall()
                tarinfo = tar.next()
                while not tarinfo is None:
                    fn = str(tarinfo.name)
                    if not fn in all_files:
                        all_files.append(fn)
                    if tarinfo.isfile() and os.path.exists(fn) and not OVERWRITE:
                        print_warning('{} already exists'.format(tarinfo.name))
                    else:
                        tar.extract(tarinfo)
                    tarinfo = tar.next()
    meta = {
        "version": version,
        "platforms": processed_platforms,
        "dependencies": deps
    }
    if 'variables' in package_meta:
        variables = package_meta['variables']
        meta['variables'] = variables
        for vn in variables:
            vinfo = variables[vn]
            if 'default' in vinfo:
                default_value = vinfo['default']
                sep = vn.find('/')
                if sep >= 0:
                    section = vn[:sep]
                    key = vn[sep+1:]
                    project_set(section, key, '"{}"'.format(default_value))
                else:
                    # wrong variable name
                    pass
    if 'android' in PLATFORMS and 'platform_android' in package_meta and 'android_module' in package_meta['platform_android']:
        android_module = package_meta['platform_android']['android_module']
        meta['android_module'] = android_module
        project_list_add('android', 'modules', android_module)
    if 'autoload' in package_meta:
        for key in package_meta['autoload']:
            project_set('autoload', key, '"{}"'.format(package_meta['autoload'][key]))
        meta['autoload'] = package_meta['autoload']
    PROJECT_META['packages'][package_name] = meta
    save_project_meta()
    # save install journal
    j_home = journal_home()
    with open(os.path.join(j_home, '{}@{}'.format(package_name, version)), 'w') as f:
        json.dump(all_files, f)
    return True

def uninstall_package(package_name):
    if not package_name in PROJECT_META['packages']:
        print_warning('{} not installed'.format(package_name))
        return
    info = PROJECT_META['packages'].pop(package_name)
    version = info['version']
    for pack in installed_packages():
        if pack == package_name:
            continue
        deps = PROJECT_META['packages'][pack]['dependencies']
        for d in deps:
            p, v = split_package_name(d)
            if p == package_name:
                err = '{} depends on {}'.format(pack, package_name)
                if FORCE:
                    print_warning(err)
                else:
                    print_error(err)
                    return
    if 'android_module' in info:
        project_list_rm('android', 'modules', info['android_module'])
    if 'autoload' in info:
        for key in info['autoload']:
            project_del('autoload', key)
    j_home = journal_home()
    journal = os.path.join(j_home, '{}@{}'.format(package_name, version))
    J = []
    try:
        _str = file_text(journal)
        J = json.loads(_str)
    except IOError as e:
        print_error('Can not find installation journal for {}@{}'.format(package_name, version))
        exit()
    dirs = []
    for fn in J:
        if os.path.isdir(fn):
            dirs.append(fn)
        elif os.path.exists(fn):
            os.remove(fn)
    for d in reversed(dirs):
        try:
            os.rmdir(d)
        except OSError:
            pass
    save_project_meta()
    os.remove(journal)
    print_bold('{} uninstalled'.format(package_name))

def install_required_packages():
    global FORCE
    force = FORCE
    FORCE = True
    for package_name in installed_packages():
        info = PROJECT_META['packages'][package_name]
        deps = info['dependencies']
        for d in deps:
            p, v = split_package_name(d)
            if not is_package_installed(p, v):
                install_package(p, v)
        ver = info['version']
        j_home = journal_home()
        journal = os.path.join(j_home, '{}@{}'.format(package_name, ver))
        if not os.path.exists(journal):
            install_package(package_name, ver)
    FORCE = force

def print_help():
    print("""
Usage: nativelib [options] [command]

Repository related commands:
    -s|--search <pattern>\tSearch packages in repository
    -I|--info <package>\t\tShow details about specific package
    -U|--update\t\t\tUpdate repository info
    -P|--pack <path>\t\tPack the plugin in the specific path into local repository
    --publish <path>\t\tPack and publish plugin in the specific path into remote repository

Repository related options:
    -C|--no-cleanup\t\tDon't remove temporary files

Project related commands:
    -i|--install <package>\tInstall package
    -u|--uninstall <package>\tUninstall package
    -l|--list\t\t\tList installed packages
    -p|--prepare\t\tPrepare project on new machine (install all required packages)

Project related options:
    --ios\t\t\tProcess iOS platform (also add iOS to project's platform list)
    --android\t\t\tProcess Android platform (also add Android to project's platform list)
    -o|--overwrite\t\tOverwrite files during installation

Other commands:
    -h|--help\t\t\tPrints this page
    --version\t\t\tPrints NativeLib version

Other options:
    -f|--force\t\t\tIgnore errors and warnings if possible
""")
    
try:
    args = sys.argv[1:]
    options, tail = getopt.getopt(args, "s:I:UP:Ci:u:lpohf", [
        "search=", "info=", "update", "pack=", "publish=",
        "no-cleanup",

        "install=", "uninstall=", "list", "prepare",
        "ios", "android", "overwrite",

        "help", "version",
        "force"])

    if len(tail) > 0:
        for p in tail:
            print_error('Unrecognized parameter: {0}'.format(p))

    storage_load()
    load_credentials()

    for op in options:
        par = op[0]
        arg = op[1]
        # Repository commands
        if par == '-s' or par == '--search':
            storage_search(arg)
            exit()
        elif par == '-I' or par == '--info':
            p, v = split_package_name(arg)
            storage_info(p, v)
            exit()
        elif par == '-U' or par == '--update':
            storage_update()
            exit()
        elif par == '-P' or par == '--pack':
            pack_plugin(arg)
            exit()
        elif par == '--publish':
            publish_plugin(arg)
            exit()

        # Repository options
        elif par == '-C' or par == '--no-cleanup':
            CLEANUP = False

        # Project commands
        elif par == '-i' or par == '--install':
            if PROJECT_META is None:
                prepare_project()
            p, v = split_package_name(arg)
            install_package(p, v)
            exit()
        elif par == '-u' or par == '--uninstall':
            if PROJECT_META is None:
                prepare_project()
            uninstall_package(arg)
            exit()
        elif par == '-l' or par == '--list':
            if PROJECT_META is None:
                prepare_project()
            list_installed_packages()
            exit()
        elif par == '-p' or par == '--prepare':
            if PROJECT_META is None:
                prepare_project()
            install_required_packages()

        # Project options
        elif par == '--ios':
            if PROJECT_META is None:
                prepare_project()
            if not 'ios' in PLATFORMS:
                PLATFORMS.append('ios')
                save_project_meta()
        elif par == '--android':
            if PROJECT_META is None:
                prepare_project()
            if not 'android' in PLATFORMS:
                PLATFORMS.append('android')
                save_project_meta()
        elif par == '-o' or par == '--overwrite':
            OVERWRITE = True

        # Other commands
        elif par == '-h' or par == '--help':
            print_help()
            exit()
        elif par == '--version':
            print(VERSION)

        # Other options
        elif par == '-f' or par == '--force':
            FORCE = True

except getopt.GetoptError as ex:
    print_error(ex)
